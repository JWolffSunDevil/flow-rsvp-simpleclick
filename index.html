<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow Tapper + Peripheral RSVP (Yes/No + Confidence + Difficulty)</title>
<style>
  :root { --bg:#0b1117; --fg:#e6edf3; --muted:#9aa7b2; --accent:#6aa6ff; }
  html,body { margin:0; padding:0; height:100%; background:var(--bg); color:var(--fg); font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;}
  #app { display:flex; align-items:center; justify-content:center; height:100%; }
  .card { width:min(900px,92vw); border:1px solid #243041; border-radius:16px; padding:28px; box-shadow:0 10px 30px rgba(0,0,0,.25); background:linear-gradient(180deg,#0e1520 0%,#0b1117 100%); }
  h1 { margin:0 0 6px 0; font-size:22px; color:#d5e2f0; }
  p { color:var(--muted); line-height:1.5; }
  .center { text-align:center; }
  .mid { font-size:36px; }
  .hint { font-size:14px; color:#93a0ad; }
  .pill { padding:8px 12px; border-radius:999px; border:1px solid #253447; color:#cfe0f6; }
  .layout { position:relative; height:60vh; min-height:420px; display:flex; align-items:center; justify-content:center; border:1px dashed #263346; border-radius:16px; margin:20px 0; }
  /* RSVP number centered and raised above the dot */
  .rsvp { position:absolute; bottom:calc(50% + 140px); left:50%; transform:translateX(-50%); font-size:72px; color:#b7c3cf; opacity:.38; user-select:none; }
  .dot { width:84px; height:84px; border-radius:50%; background:#6aa6ff; opacity:.35; transition:transform .08s, opacity .08s; transform:scale(1); }
  .dot.flash { opacity:.95; transform:scale(1.08); }
  .btn { display:inline-block; background:#1a2634; border:1px solid #2a3a50; color:#d7e6fb; padding:10px 14px; border-radius:10px; cursor:pointer; }
  .btn:hover{ filter:brightness(1.1);}
  .row { display:flex; gap:12px; justify-content:center; align-items:center; flex-wrap:wrap; margin-top:12px;}
  .two { display:grid; grid-template-columns:1fr 1fr; gap:16px; }
  .choice { padding:14px; border:1px solid #2b3a53; border-radius:12px; text-align:center; font-size:28px; cursor:pointer; user-select:none; }
  .choice:hover { outline:2px solid #3b4f70; }
  input[type="text"]{ width:260px; padding:10px 12px; border-radius:10px; border:1px solid #2a3a50; background:#0f1722; color:#d7e6fb; }
</style>
</head>
<body>
<div id="app"><div class="card"><div id="screen"></div></div></div>
<script>
(function(){
  // ===== CONFIG =====
  // Three rounds: Easy, Medium, Hard
  // RSVP is very fast: ~40ms, ~29ms, ~22ms intervals respectively
  const ROUNDS = [
    {name:"Easy",   bpm:60,  rsvpHz:25, targetPool:[3,8,12,17,20]},  // scheduled real targets
    {name:"Medium", bpm:90,  rsvpHz:35, targetPool:[2,5,11,14,19]},
    {name:"Hard",   bpm:120, rsvpHz:45, targetPool:[1,6,9,15,18]},
  ];

  const ROUND_DURATION_RANGE_MS = [15000, 60000]; // 15..60s
  const TARGETS_PER_ROUND = 6;
  const TARGET_FIRST_MS   = [3000,5000];
  const TARGET_GAP_MS     = [7000,11000];

  // Keys
  const YES_KEY   = "KeyF";           // recognition: Yes
  const NO_KEY    = "KeyJ";           // recognition: No
  const CONF_KEYS = ["Digit1","Digit2","Digit3","Digit4"];          // 1..4 confidence
  const LIKERT5   = ["Digit1","Digit2","Digit3","Digit4","Digit5"]; // 1..5 difficulty/flow
  const LEFT_KEY  = "KeyF";           // 2AFC time: Left
  const RIGHT_KEY = "KeyJ";           // 2AFC time: Right

  // ===== STATE =====
  const S = {
    pid: "",
    phase: "pid", roundIndex: -1,
    rafId: 0, keyHandler: null, keyTimeout: null,
    roundStart: 0, endAt: 0, nextBeatAt: 0, beatInterval: 600,
    nextRSVPAt: 0, rsvpInterval: 40,
    targets: [],                    // [{at, digit, shown}]
    rsvpShown: new Array(21).fill(0), // digits 1..20 seen (index 0 unused)
    transitioning: false,
    log: [],
  };

  // ===== UTILS =====
  const now = ()=>performance.now();
  const randint = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;
  const choice = arr => arr[Math.floor(Math.random()*(arr.length))];
  const shuffle = (arr)=>{ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j]]=[arr[i],arr[j]]; } return arr; };
  // Fix the shuffle function (typo above). Correct implementation:
  function shuffleFixed(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }

  const screen = document.getElementById('screen');
  const html   = (s,...v)=> s.map((x,i)=> x + (v[i]??'')).join('');

  window.addEventListener('keydown', e=>{ if (typeof S.keyHandler==='function') S.keyHandler(e); });
  function setKeyHandler(allowed, ms, cb){
    clearKeyHandler();
    S.keyHandler = e=>{
      if (!allowed || allowed.includes(e.code)) { clearKeyHandler(); cb(e.code); }
    };
    if (ms>0) S.keyTimeout = setTimeout(()=>{ clearKeyHandler(); cb(null); }, ms);
  }
  function clearKeyHandler(){ if (S.keyTimeout){ clearTimeout(S.keyTimeout); S.keyTimeout=null; } S.keyHandler=null; }
  function cancelLoop(){ if (S.rafId){ cancelAnimationFrame(S.rafId); S.rafId=0; } }

  // ===== TARGET SCHEDULER =====
  function scheduleTargets(duration, targetPool){
    const out=[]; let t = randint(...TARGET_FIRST_MS);
    for (let i=0;i<TARGETS_PER_ROUND;i++){
      out.push({at:t, digit: choice(targetPool), shown:false});
      t += randint(...TARGET_GAP_MS);
      if (t>duration-1000) break;
    }
    return out;
  }

  // ===== PID PROMPT =====
  function pidPrompt(){
    cancelLoop(); clearKeyHandler(); S.phase='pid';
    screen.innerHTML = html`
      <h1>Enter Participant ID</h1>
      <p class="hint">Type your ID, then press Enter.</p>
      <div class="center" style="margin-top:10px">
        <input id="pid" type="text" placeholder="e.g., P001" autofocus />
      </div>
    `;
    const el = document.getElementById('pid');
    el.focus();
    S.keyHandler = (e)=>{
      if (e.code==='Enter'){
        const v = el.value.trim();
        if (v.length>0){ S.pid = v; intro(); }
      }
    };
  }

  // ===== INTRO =====
  function intro(){
    cancelLoop(); clearKeyHandler(); S.phase='intro';
    screen.innerHTML = html`
      <h1>Tap the dot in rhythm</h1>
      <p>Press <strong>SPACE</strong> whenever the dot flashes. Keep your eyes on the dot and play naturally; numbers will also flash above the dot. We'll test whether you can recall numbers shown after the game. This test will measure intelligence.</p>
      <div class="layout"><div class="rsvp">17</div><div class="dot" id="dot"></div></div>
      <div class="center"><button class="btn" id="start">Start</button></div>
      <div class="row">
        <span class="pill">After each round: number recognition (Yes/No)</span>
        <span class="pill">Confidence 1–4</span>
        <span class="pill">Difficulty 1–5</span>
        <span class="pill">Flow + time 2AFC</span>
      </div>`;
    document.getElementById('start').onclick = ()=> startNextRound();
  }

  function startNextRound(){
    if (S.transitioning) return;
    S.transitioning = true;
    S.roundIndex++;
    if (S.roundIndex>=ROUNDS.length) { finish(); return; }
    setTimeout(()=>{ S.transitioning=false; runRound(ROUNDS[S.roundIndex]); }, 0);
  }

  // ===== RUN ROUND =====
  function runRound(cfg){
    cancelLoop(); clearKeyHandler(); S.phase='round';
    S.roundStart = now();
    const runDuration = randint(ROUND_DURATION_RANGE_MS[0], ROUND_DURATION_RANGE_MS[1]);
    S.endAt      = S.roundStart + runDuration;

    S.beatInterval = 60000/cfg.bpm;
    S.nextBeatAt   = S.roundStart + S.beatInterval;
    S.rsvpInterval = Math.max(20, Math.round(1000/cfg.rsvpHz));
    S.nextRSVPAt   = S.roundStart + S.rsvpInterval;

    S.targets     = scheduleTargets(runDuration, cfg.targetPool);
    S.rsvpShown   = new Array(21).fill(0); // 1..20

    S.log.push({pid:S.pid, type:'ROUND_START', round:S.roundIndex, roundName:cfg.name, ts:0,
                bpm:cfg.bpm, rsvpHz:cfg.rsvpHz, plannedMs:runDuration});

    screen.innerHTML = html`
      <div class="row" style="justify-content:space-between">
        <div class="pill">${cfg.name}</div>
        <div class="hint">Press SPACE</div>
      </div>
      <div class="layout"><div id="rsvp" class="rsvp"></div><div id="dot" class="dot"></div></div>`;
    const dot   = document.getElementById('dot');
    const elRSV = document.getElementById('rsvp');

    setKeyHandler(["Space"], 0, ()=>{
      const t = now();
      S.log.push({pid:S.pid, type:'TAP', round:S.roundIndex, roundName:cfg.name, ts:Math.round(t-S.roundStart)});
    });

    function loop(){
      const t = now();
      if (t>=S.endAt){ cancelLoop(); clearKeyHandler(); return postRound(cfg, runDuration); }

      // Jittered beat flashes (±35%)
      while (t>=S.nextBeatAt){
        const jitter = 0.35;
        const base = S.beatInterval;
        const factor = 1 + (Math.random()*2-1)*jitter;
        S.nextBeatAt = t + base * factor;
        dot.classList.add('flash');
        setTimeout(()=>dot.classList.remove('flash'),120);
        S.log.push({pid:S.pid, type:'BEAT', round:S.roundIndex, roundName:cfg.name, ts:Math.round(t-S.roundStart)});
      }

      // RSVP digits 1..20 (force scheduled targets when near their time)
      while (t>=S.nextRSVPAt){
        S.nextRSVPAt += S.rsvpInterval;
        let digit = randint(1,20);
        const elapsed = t - S.roundStart;

        for (const tgt of S.targets){
          if (!tgt.shown && Math.abs(elapsed - tgt.at) <= S.rsvpInterval){
            digit = tgt.digit; tgt.shown=true; break;
          }
        }

        S.rsvpShown[digit] = 1;
        elRSV.textContent = String(digit);
        S.log.push({pid:S.pid, type:'RSVP', round:S.roundIndex, roundName:cfg.name,
                    ts:Math.round(elapsed), digit});
      }

      S.rafId = requestAnimationFrame(loop);
    }
    S.rafId = requestAnimationFrame(loop);
  }

  // ===== AFTER ROUND =====
  function postRound(cfg, runDuration){
    S.log.push({pid:S.pid, type:'ROUND_END', round:S.roundIndex, roundName:cfg.name,
                ts:Math.round(now()-S.roundStart)});

    // Unique target digits that actually showed
    const shownTargets = [];
    for (const t of S.targets){ if (t.shown) shownTargets.push(t.digit); }
    const uniqTargets = Array.from(new Set(shownTargets));

    // Foil pool = digits 1..20 that did NOT appear at all
    const unseen = [];
    for (let d=1; d<=20; d++){ if (!S.rsvpShown[d]) unseen.push(d); }
    if (unseen.length===0){
      for (let d=1; d<=20; d++){ if (!uniqTargets.includes(d)) unseen.push(d); }
    }

    // Build exactly TWO Yes/No probes: one target (if any) + one foil
    const probes = [];
    if (uniqTargets.length>0) probes.push({digit: choice(uniqTargets), isTarget:true});
    if (unseen.length>0)      probes.push({digit: choice(unseen), isTarget:false});
    while (probes.length<2)   probes.push({digit: unseen.length?choice(unseen):randint(1,20), isTarget:false});

    shuffleFixed(probes);
    let idx = 0;
    const next = ()=> {
      if (idx >= probes.length) return postRoundSurvey(cfg, runDuration);
      yesNoProbe(probes[idx++], next, cfg);
    };
    next();
  }

  function yesNoProbe(probe, done, cfg){
    cancelLoop(); clearKeyHandler();
    screen.innerHTML = html`
      <h1>Did you see this number?</h1>
      <div class="center mid" style="margin:16px 0">${probe.digit}</div>
      <p class="center hint">Press <strong>F</strong> = Yes, <strong>J</strong> = No</p>
    `;
    const start = now();
    setKeyHandler([YES_KEY, NO_KEY], 20000, (code)=>{
      const rt = Math.round(now()-start);
      const respYes = code===YES_KEY ? 1 : code===NO_KEY ? 0 : null;
      const correct = respYes===null ? 0 : (respYes===1 ? (probe.isTarget?1:0) : (probe.isTarget?0:1));
      S.log.push({
        pid:S.pid, type:'PROBE', round:S.roundIndex, roundName:cfg.name,
        ts:Math.round(now()-S.roundStart),
        probe_digit: probe.digit, is_target: probe.isTarget?1:0,
        resp_yes: respYes, correct
      });
      difficultyThenConfidence(done, cfg);
    });
  }

  function difficultyThenConfidence(next, cfg){
    // Difficulty with labels (1..5)
    cancelLoop(); clearKeyHandler();
    screen.innerHTML = html`
      <h1>How difficult was that?</h1>
      <div class="row">
        <span class="pill">1 · Very easy</span>
        <span class="pill">2 · Easy</span>
        <span class="pill">3 · Moderate</span>
        <span class="pill">4 · Hard</span>
        <span class="pill">5 · Very hard</span>
      </div>
      <p class="center hint">Press 1..5</p>`;
    const t0 = now();
    setKeyHandler(LIKERT5, 20000, code=>{
      const difficulty = code ? (LIKERT5.indexOf(code)+1) : null;
      const rt = Math.round(now()-t0);
      S.log.push({pid:S.pid, type:'DIFF', round:S.roundIndex, roundName:cfg.name, ts:Math.round(now()-S.roundStart), difficulty, rt});
      confidence(next, cfg);
    });
  }

  function confidence(next, cfg){
    cancelLoop(); clearKeyHandler();
    screen.innerHTML = html`
      <h1>Confidence</h1>
      <div class="row">
        <span class="pill">1 · Not at all</span>
        <span class="pill">2 · Slightly</span>
        <span class="pill">3 · Mostly</span>
        <span class="pill">4 · Very</span>
      </div>
      <p class="center hint">Press 1..4</p>`;
    const t0 = now();
    setKeyHandler(CONF_KEYS, 20000, code=>{
      const confidence = code ? (CONF_KEYS.indexOf(code)+1) : null;
      const rt = Math.round(now()-t0);
      S.log.push({pid:S.pid, type:'CONF', round:S.roundIndex, roundName:cfg.name, ts:Math.round(now()-S.roundStart), confidence, rt});
      next();
    });
  }

  // ===== FLOW SURVEY (3 items) & TIME 2AFC =====
  function postRoundSurvey(cfg, runDuration){
    cancelLoop(); clearKeyHandler();
    const qs = [
      'I was fully concentrated (1..5)',
      'I lost track of time (1..5)',
      'I enjoyed that round (1..5)'
    ];
    let i=0;
    const ask=()=>{
      if (i<qs.length){
        screen.innerHTML = html`<h1>After-round questions</h1><p class="center mid">${qs[i]}</p><p class="center hint">Press 1..5</p>`;
        setKeyHandler(LIKERT5,20000, code=>{
          const val = code ? (LIKERT5.indexOf(code)+1) : null;
          S.log.push({pid:S.pid, type:'FLOW', round:S.roundIndex, roundName:cfg.name, item:i+1, val});
          i++; ask();
        });
      } else { timeTwoAFC(cfg, runDuration); }
    };
    ask();
  }

  function timeTwoAFC(cfg, runDuration){
    cancelLoop(); clearKeyHandler();
    // Actual seconds (rounded)
    const actualSec = Math.round(runDuration/1000);
    // Build a plausible foil: differ by 5..20s, clamp to 15..60
    let delta = choice([5,6,7,8,9,10,12,15,18,20]);
    if (Math.random()<0.5) delta = -delta;
    let foilSec = Math.max(15, Math.min(60, actualSec + delta));
    if (foilSec === actualSec) foilSec = Math.max(15, Math.min(60, actualSec + (delta>0 ? 5 : -5)));
    const leftIsCorrect = Math.random()<0.5;
    const L = leftIsCorrect ? actualSec : foilSec;
    const R = leftIsCorrect ? foilSec : actualSec;

    screen.innerHTML = html`
      <h1>How long did that round last?</h1>
      <div class="two">
        <div class="choice" id="left">${L} sec</div>
        <div class="choice" id="right">${R} sec</div>
      </div>
      <p class="center hint">Press <strong>F</strong> (left) or <strong>J</strong> (right)</p>
    `;
    const start = now();
    setKeyHandler([LEFT_KEY, RIGHT_KEY], 20000, (code)=>{
      const rt = Math.round(now()-start);
      const pickLeft = code===LEFT_KEY ? 1 : code===RIGHT_KEY ? 0 : null;
      const chosen = pickLeft===null ? null : (pickLeft ? L : R);
      const correct = chosen===null ? 0 : (chosen===actualSec ? 1 : 0);
      S.log.push({
        pid:S.pid, type:'TIME_2AFC', round:S.roundIndex, roundName:cfg.name,
        left:L, right:R, leftIsCorrect:leftIsCorrect?1:0, choice_left:pickLeft, chosen, correct, rt
      });
      startNextRound();
    });
  }

  // ===== FINISH & CSV =====
  function finish(){
    cancelLoop(); clearKeyHandler();
    // Long-format CSV (one row per event)
    const cols = ["pid","round","roundName","type","ts","digit","probe_digit","is_target","resp_yes","correct","confidence","difficulty","seconds","bpm","rsvpHz","plannedMs","left","right","leftIsCorrect","choice_left","chosen"];
    const lines = [cols.join(",")];
    for (const r of S.log){
      const row = {
        pid: r.pid ?? S.pid,
        round: r.round ?? "",
        roundName: r.roundName ?? "",
        type: r.type ?? "",
        ts: r.ts ?? "",
        digit: r.digit ?? "",
        probe_digit: r.probe_digit ?? "",
        is_target: r.is_target ?? "",
        resp_yes: r.resp_yes ?? "",
        correct: r.correct ?? "",
        confidence: r.confidence ?? "",
        difficulty: r.difficulty ?? "",
        seconds: r.seconds ?? "",
        bpm: r.bpm ?? "",
        rsvpHz: r.rsvpHz ?? "",
        plannedMs: r.plannedMs ?? "",
        left: r.left ?? "",
        right: r.right ?? "",
        leftIsCorrect: r.leftIsCorrect ?? "",
        choice_left: r.choice_left ?? "",
        chosen: r.chosen ?? ""
      };
      lines.push(cols.map(k=>row[k]).join(","));
    }
    const csv = lines.join("\n");
    const url = URL.createObjectURL(new Blob([csv],{type:'text/csv'}));
    const fname = `flow_rsvp_${S.pid||'anon'}.csv`;
    screen.innerHTML = html`<h1>Finished 🎉</h1><p class="center">Thanks for participating.</p><div class="center" style="margin-top:16px"><a class="btn" id="dl" download="${fname}">Download results CSV</a></div>`;
    document.getElementById('dl').href = url;
  }

  // go
  pidPrompt();
})();
</script>
</body>
</html>
