<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow Tapper + Peripheral RSVP (Yes/No + Likerts + Time 2AFC)</title>
<style>
  :root { --bg:#0b1117; --fg:#e6edf3; --muted:#9aa7b2; --accent:#6aa6ff; }
  html,body { margin:0; padding:0; height:100%; background:var(--bg); color:var(--fg); font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;}
  #app { display:flex; align-items:center; justify-content:center; height:100%; }
  .card { width:min(900px,92vw); border:1px solid #243041; border-radius:16px; padding:28px; box-shadow:0 10px 30px rgba(0,0,0,.25); background:linear-gradient(180deg,#0e1520 0%,#0b1117 100%); }
  h1 { margin:0 0 6px 0; font-size:22px; color:#d5e2f0; }
  p { color:var(--muted); line-height:1.5; }
  .center { text-align:center; }
  .mid { font-size:36px; }
  .hint { font-size:14px; color:#93a0ad; }
  .pill { padding:8px 12px; border-radius:999px; border:1px solid #253447; color:#cfe0f6; }
  .layout { position:relative; height:60vh; min-height:420px; display:flex; align-items:center; justify-content:center; border:1px dashed #263346; border-radius:16px; margin:20px 0; }
  .rsvp { position:absolute; bottom:calc(50% + 140px); left:50%; transform:translateX(-50%); font-size:72px; color:#b7c3cf; opacity:.38; user-select:none; }
  .dot { width:84px; height:84px; border-radius:50%; background:#6aa6ff; opacity:.35; transition:transform .08s, opacity .08s; transform:scale(1); }
  .dot.flash { opacity:.95; transform:scale(1.08); }
  .btn { display:inline-block; background:#1a2634; border:1px solid #2a3a50; color:#d7e6fb; padding:10px 14px; border-radius:10px; cursor:pointer; }
  .btn:hover{ filter:brightness(1.1);}
  .row { display:flex; gap:12px; justify-content:center; align-items:center; flex-wrap:wrap; margin-top:12px;}
  .two { display:grid; grid-template-columns:1fr 1fr; gap:16px; }
  .choice { padding:14px; border:1px solid #2b3a53; border-radius:12px; text-align:center; font-size:28px; cursor:pointer; user-select:none; }
  .choice:hover { outline:2px solid #3b4f70; }
  input[type="text"]{ width:260px; padding:10px 12px; border-radius:10px; border:1px solid #2a3a50; background:#0f1722; color:#d7e6fb; }
</style>
</head>
<body>
<div id="app"><div class="card"><div id="screen"></div></div></div>
<script>
(function(){
  // ===== CONFIG =====
  const ROUNDS = [
    {name:"Easy",   bpm:60,  rsvpHz:25, targetPool:[3,8,12,17,20]},
    {name:"Medium", bpm:90,  rsvpHz:35, targetPool:[2,5,11,14,19]},
    {name:"Hard",   bpm:120, rsvpHz:45, targetPool:[1,6,9,15,18]},
  ];
  const ROUND_DURATION_RANGE_MS = [15000, 60000]; // 15..60s
  const TARGETS_PER_ROUND = 6;
  const TARGET_FIRST_MS   = [3000,5000];
  const TARGET_GAP_MS     = [7000,11000];

  // Keys
  const YES_KEY   = "KeyF";           // recognition: Yes
  const NO_KEY    = "KeyJ";           // recognition: No
  const LIKERT5   = ["Digit1","Digit2","Digit3","Digit4","Digit5"]; // 1..5 for all after-round questions
  const LEFT_KEY  = "KeyF";           // time 2AFC: Left
  const RIGHT_KEY = "KeyJ";           // time 2AFC: Right

  // Likert labels
  const LABELS_CONF_5 = ["1 · Not at all","2 · Slightly","3 · Somewhat","4 · Mostly","5 · Very"];
  const LABELS_DIFF_5 = ["1 · Very easy","2 · Easy","3 · Moderate","4 · Hard","5 · Very hard"];
  const LABELS_CONC_5 = ["1 · Extremely concentrated","2 · Very","3 · Moderately","4 · Slightly","5 · Not at all"];
  const LABELS_LOST_5 = ["1 · Not at all","2 · Slightly","3 · Somewhat","4 · Mostly","5 · Completely"];

  // ===== STATE =====
  const S = {
    pid: "",
    phase: "pid", roundIndex: -1,
    rafId: 0, keyHandler: null, keyTimeout: null,
    roundStart: 0, endAt: 0, nextBeatAt: 0, beatInterval: 600,
    nextRSVPAt: 0, rsvpInterval: 40,
    targets: [],                    // [{at, digit, shown}]
    rsvpShown: new Array(21).fill(0), // digits 1..20 seen (index 0 unused)
    transitioning: false,
    roundMeta: {}, // roundIndex -> {nTargetsShown}
    log: [],
  };

  // ===== UTILS =====
  const now = ()=>performance.now();
  const randint = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;
  const choice  = arr => arr[Math.floor(Math.random()*arr.length)];
  function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }

  const screen = document.getElementById('screen');
  const html   = (s,...v)=> s.map((x,i)=> x + (v[i]??'')).join('');

  window.addEventListener('keydown', e=>{ if (typeof S.keyHandler==='function') S.keyHandler(e); });
  function setKeyHandler(allowed, ms, cb){
    clearKeyHandler();
    S.keyHandler = e=>{
      if (!allowed || allowed.includes(e.code)) { clearKeyHandler(); cb(e.code); }
    };
    if (ms>0) S.keyTimeout = setTimeout(()=>{ clearKeyHandler(); cb(null); }, ms);
  }
  function clearKeyHandler(){ if (S.keyTimeout){ clearTimeout(S.keyTimeout); S.keyTimeout=null; } S.keyHandler=null; }
  function cancelLoop(){ if (S.rafId){ cancelAnimationFrame(S.rafId); S.rafId=0; } }

  // ===== TARGET SCHEDULER =====
  function scheduleTargets(duration, targetPool){
    const out=[]; let t = randint(...TARGET_FIRST_MS);
    for (let i=0;i<TARGETS_PER_ROUND;i++){
      out.push({at:t, digit: choice(targetPool), shown:false});
      t += randint(...TARGET_GAP_MS);
      if (t>duration-1000) break;
    }
    return out;
  }

  // ===== PID PROMPT =====
  function pidPrompt(){
    cancelLoop(); clearKeyHandler(); S.phase='pid';
    screen.innerHTML = html`
      <h1>Enter Participant ID</h1>
      <p class="hint">Type your ID, then press Enter.</p>
      <div class="center" style="margin-top:10px">
        <input id="pid" type="text" placeholder="e.g., P001" autofocus />
      </div>
    `;
    const el = document.getElementById('pid');
    el.focus();
    S.keyHandler = (e)=>{
      if (e.code==='Enter'){
        const v = el.value.trim();
        if (v.length>0){ S.pid = v; intro(); }
      }
    };
  }

  // ===== INTRO =====
  function intro(){
    cancelLoop(); clearKeyHandler(); S.phase='intro';
    screen.innerHTML = html`
      <h1>Tap the dot in rhythm</h1>
      <p>Press <strong>SPACE</strong> whenever the dot flashes. Keep your eyes on the dot and play naturally; numbers will also flash above the dot. We'll test whether you can recall numbers shown after the game. This test will measure intelligence. <br><br><em>This game has three rounds, and should take less than 10 minutes to complete. Thank you for your full participation.</em></p>
      <div class="layout"><div class="rsvp">17</div><div class="dot" id="dot"></div></div>
      <div class="center"><button class="btn" id="start">Start</button></div>`;
    document.getElementById('start').onclick = ()=> startNextRound();
  }

  function startNextRound(){
    if (S.transitioning) return;
    S.transitioning = true;
    S.roundIndex++;
    if (S.roundIndex>=ROUNDS.length) { finish(); return; }
    setTimeout(()=>{ S.transitioning=false; runRound(ROUNDS[S.roundIndex]); }, 0);
  }

  // ===== RUN ROUND =====
  function runRound(cfg){
    cancelLoop(); clearKeyHandler(); S.phase='round';
    S.roundStart = now();
    const runDuration = randint(...ROUND_DURATION_RANGE_MS);
    S.endAt      = S.roundStart + runDuration;

    S.beatInterval = 60000/cfg.bpm;
    S.nextBeatAt   = S.roundStart + S.beatInterval;
    S.rsvpInterval = Math.max(20, Math.round(1000/cfg.rsvpHz));
    S.nextRSVPAt   = S.roundStart + S.rsvpInterval;

    S.targets     = scheduleTargets(runDuration, cfg.targetPool);
    S.rsvpShown   = new Array(21).fill(0); // 1..20

    S.log.push({pid:S.pid, type:'ROUND_START', round:S.roundIndex, roundName:cfg.name, ts:0,
                bpm:cfg.bpm, rsvpHz:cfg.rsvpHz, plannedMs:runDuration});

    screen.innerHTML = html`
      <div class="row" style="justify-content:space-between">
        <div class="pill">${cfg.name}</div>
        <div class="hint">Press SPACE</div>
      </div>
      <div class="layout"><div id="rsvp" class="rsvp"></div><div id="dot" class="dot"></div></div>`;
    const dot   = document.getElementById('dot');
    const elRSV = document.getElementById('rsvp');

    setKeyHandler(["Space"], 0, ()=>{
      const t = now();
      S.log.push({pid:S.pid, type:'TAP', round:S.roundIndex, roundName:cfg.name, ts:Math.round(t-S.roundStart)});
    });

    function loop(){
      const t = now();
      if (t>=S.endAt){ cancelLoop(); clearKeyHandler(); return postRound(cfg, runDuration); }

      while (t>=S.nextBeatAt){
        const jitter = 0.35;
        const base = S.beatInterval;
        const factor = 1 + (Math.random()*2-1)*jitter;
        S.nextBeatAt = t + base * factor;
        dot.classList.add('flash');
        setTimeout(()=>dot.classList.remove('flash'),120);
        S.log.push({pid:S.pid, type:'BEAT', round:S.roundIndex, roundName:cfg.name, ts:Math.round(t-S.roundStart)});
      }

      while (t>=S.nextRSVPAt){
        S.nextRSVPAt += S.rsvpInterval;
        let digit = randint(1,20);
        const elapsed = t - S.roundStart;

        // force scheduled targets near their time
        for (const tgt of S.targets){
          if (!tgt.shown && Math.abs(elapsed - tgt.at) <= S.rsvpInterval){
            digit = tgt.digit; tgt.shown=true; break;
          }
        }

        S.rsvpShown[digit] = 1;
        elRSV.textContent = String(digit);
        S.log.push({pid:S.pid, type:'RSVP', round:S.roundIndex, roundName:cfg.name,
                    ts:Math.round(elapsed), digit});
      }

      S.rafId = requestAnimationFrame(loop);
    }
    S.rafId = requestAnimationFrame(loop);
  }

  // ===== AFTER ROUND =====
  function postRound(cfg, runDuration){
    // compute how many scheduled targets actually showed this round
    const nTargetsShown = new Set(S.targets.filter(t=>t.shown).map(t=>t.digit)).size;
    S.roundMeta[S.roundIndex] = { nTargetsShown };
    S.log.push({pid:S.pid, type:'ROUND_META', round:S.roundIndex, roundName:cfg.name, nTargetsShown});

    S.log.push({pid:S.pid, type:'ROUND_END', round:S.roundIndex, roundName:cfg.name,
                ts:Math.round(now()-S.roundStart)});

    // Unique target digits that actually showed
    const uniqTargets = Array.from(new Set(S.targets.filter(t=>t.shown).map(t=>t.digit)));
    // Foil pool = digits 1..20 that did NOT appear at all
    const unseen = []; for (let d=1; d<=20; d++){ if (!S.rsvpShown[d]) unseen.push(d); }
    if (unseen.length===0){
      for (let d=1; d<=20; d++){ if (!uniqTargets.includes(d)) unseen.push(d); }
    }

    // Exactly ONE probe: prefer a real target, else a true foil
    let probe;
    if (uniqTargets.length>0) probe = {digit: choice(uniqTargets), isTarget:true};
    else                      probe = {digit: choice(unseen.length?unseen:[randint(1,20)]), isTarget:false};

    yesNoProbe(probe, ()=> afterRoundSequence(cfg, runDuration), cfg);
  }

  function yesNoProbe(probe, done, cfg){
    cancelLoop(); clearKeyHandler();
    screen.innerHTML = html`
      <h1>Did you see this number?</h1>
      <div class="center mid" style="margin:16px 0">${probe.digit}</div>
      <p class="center hint">Press <strong>F</strong> = Yes, <strong>J</strong> = No</p>
    `;
    const start = now();
    setKeyHandler([YES_KEY, NO_KEY], 20000, (code)=>{
      const rt = Math.round(now()-start);
      const respYes = code===YES_KEY ? 1 : code===NO_KEY ? 0 : null;
      const correct = respYes===null ? 0 : (respYes===1 ? (probe.isTarget?1:0) : (probe.isTarget?0:1));
      S.log.push({
        pid:S.pid, type:'PROBE', round:S.roundIndex, roundName:cfg.name,
        ts:Math.round(now()-S.roundStart),
        probe_digit: probe.digit, is_target: probe.isTarget?1:0,
        resp_yes: respYes, correct
      });
      done();
    });
  }

  // ===== Reusable Likert UI =====
  function askLikert(title, labels, keyset, logType, valueField, next){
    cancelLoop(); clearKeyHandler();
    screen.innerHTML = html`
      <h1>${title}</h1>
      <div class="row">
        ${labels.map(l=>`<span class="pill">${l}</span>`).join("")}
      </div>
      <p class="center hint">Press 1..${labels.length}</p>`;
    const t0 = now();
    setKeyHandler(keyset, 20000, code=>{
      const v = code ? (keyset.indexOf(code)+1) : null;
      const rt = Math.round(now()-t0);
      const rec = {pid:S.pid, type:logType, round:S.roundIndex, roundName:ROUNDS[S.roundIndex].name, ts:Math.round(now()-S.roundStart), rt};
      if (valueField) rec[valueField] = v; else rec.val = v;
      S.log.push(rec);
      next();
    });
  }

  // Order: Confidence → Difficulty → Concentration → Lost-time → Time 2AFC
  function afterRoundSequence(cfg, runDuration){
    askLikert("Confidence", LABELS_CONF_5, LIKERT5, "CONF", "confidence", ()=> {
      askLikert("How difficult was that?", LABELS_DIFF_5, LIKERT5, "DIFF", "difficulty", ()=> {
        askLikert("I was fully concentrated (1..5)", LABELS_CONC_5, LIKERT5, "FLOW_CONC", "concentration", ()=> {
          askLikert("I lost track of time (1..5)", LABELS_LOST_5, LIKERT5, "FLOW_LOST", "lost_time", ()=> {
            timeTwoAFC(cfg, runDuration);
          });
        });
      });
    });
  }

  // ===== TIME 2AFC =====
  function timeTwoAFC(cfg, runDuration){
    cancelLoop(); clearKeyHandler();
    const actualSec = Math.round(runDuration/1000);
    let delta = choice([5,6,7,8,9,10,12,15,18,20]);
    if (Math.random()<0.5) delta = -delta;
    let foilSec = Math.max(15, Math.min(60, actualSec + delta));
    if (foilSec === actualSec) foilSec = Math.max(15, Math.min(60, actualSec + (delta>0 ? 5 : -5)));
    const leftIsCorrect = Math.random()<0.5;
    const L = leftIsCorrect ? actualSec : foilSec;
    const R = leftIsCorrect ? foilSec : actualSec;

    screen.innerHTML = html`
      <h1>How long did that round last?</h1>
      <div class="two">
        <div class="choice" id="left">${L} sec</div>
        <div class="choice" id="right">${R} sec</div>
      </div>
      <p class="center hint">Press <strong>F</strong> (left) or <strong>J</strong> (right)</p>
    `;
    const start = now();
    setKeyHandler([LEFT_KEY, RIGHT_KEY], 20000, (code)=>{
      const rt = Math.round(now()-start);
      const pickLeft = code===LEFT_KEY ? 1 : code===RIGHT_KEY ? 0 : null;
      const chosen = pickLeft===null ? null : (pickLeft ? L : R);
      const correct = chosen===null ? 0 : (chosen===actualSec ? 1 : 0);
      S.log.push({
        pid:S.pid, type:'TIME_2AFC', round:S.roundIndex, roundName:cfg.name,
        left:L, right:R, leftIsCorrect:leftIsCorrect?1:0, choice_left:pickLeft, chosen, correct, rt
      });
      startNextRound();
    });
  }

  // ===== FINISH & CSVs =====
  function finish(){
    cancelLoop(); clearKeyHandler();

    // 1) Events CSV (long)
    const cols = ["pid","round","roundName","type","ts","digit","probe_digit","is_target","resp_yes","correct","confidence","difficulty","concentration","lost_time","seconds","bpm","rsvpHz","plannedMs","left","right","leftIsCorrect","choice_left","chosen"];
    const lines = [cols.join(",")];
    for (const r of S.log){
      const row = {
        pid: r.pid ?? S.pid,
        round: r.round ?? "",
        roundName: r.roundName ?? "",
        type: r.type ?? "",
        ts: r.ts ?? "",
        digit: r.digit ?? "",
        probe_digit: r.probe_digit ?? "",
        is_target: r.is_target ?? "",
        resp_yes: r.resp_yes ?? "",
        correct: r.correct ?? "",
        confidence: r.confidence ?? "",
        difficulty: r.difficulty ?? "",
        concentration: r.concentration ?? "",
        lost_time: r.lost_time ?? "",
        seconds: r.seconds ?? "",
        bpm: r.bpm ?? "",
        rsvpHz: r.rsvpHz ?? "",
        plannedMs: r.plannedMs ?? "",
        left: r.left ?? "",
        right: r.right ?? "",
        leftIsCorrect: r.leftIsCorrect ?? "",
        choice_left: r.choice_left ?? "",
        chosen: r.chosen ?? ""
      };
      lines.push(cols.map(k=>row[k]).join(","));
    }
    const csvEvents = lines.join("\n");
    const urlEvents = URL.createObjectURL(new Blob([csvEvents],{type:'text/csv'}));
    const fnameEvents = `flow_rsvp_events_${S.pid||'anon'}.csv`;

    // 2) Round Summary CSV (clear names)
    const sumCols = [
      "participant_id","round_index","round_name",
      "planned_duration_seconds","actual_duration_seconds",
      "taps_count","beats_count","n_targets_shown",
      "recognition_digit","recognition_was_target","recognition_yes","recognition_correct",
      "confidence_1to5","difficulty_1to5","concentration_1to5","lost_time_1to5",
      "time_left_option_seconds","time_right_option_seconds","time_choice_left","time_chosen_seconds","time_correct"
    ];
    const sumLines = [sumCols.join(",")];

    const allRounds = Array.from(new Set(S.log.map(x=>x.round))).filter(r=>r!==undefined && r!==null);
    for (const rIdx of allRounds){
      const rows = S.log.filter(x=>x.round===rIdx);
      const roundName = rows.find(x=>x.roundName)?.roundName || "";
      const plannedMs = (rows.find(x=>x.type==="ROUND_START")?.plannedMs) || "";
      const actualMs  = (rows.find(x=>x.type==="ROUND_END")?.ts) || "";
      const tapsCount  = rows.filter(x=>x.type==="TAP").length;
      const beatsCount = rows.filter(x=>x.type==="BEAT").length;
      const nTargetsShown = rows.find(x=>x.type==="ROUND_META")?.nTargetsShown ?? "";

      const probe = rows.find(x=>x.type==="PROBE");
      const conf  = rows.find(x=>x.type==="CONF")?.confidence ?? "";
      const diff  = rows.find(x=>x.type==="DIFF")?.difficulty ?? "";
      const conc  = rows.find(x=>x.type==="FLOW_CONC")?.concentration ?? "";
      const lost  = rows.find(x=>x.type==="FLOW_LOST")?.lost_time ?? "";

      const time2 = rows.find(x=>x.type==="TIME_2AFC");
      const left  = time2?.left ?? "";
      const right = time2?.right ?? "";
      const choice_left = time2?.choice_left ?? "";
      const chosen = time2?.chosen ?? "";
      const time_correct = time2?.correct ?? "";

      sumLines.push([
        S.pid,
        rIdx,
        roundName,
        plannedMs?Math.round(plannedMs/1000):"",
        actualMs?Math.round(actualMs/1000):"",
        tapsCount, beatsCount, nTargetsShown,
        probe?.probe_digit ?? "",
        probe?.is_target ?? "",
        probe?.resp_yes ?? "",
        probe?.correct ?? "",
        conf, diff, conc, lost,
        left, right, choice_left, chosen, time_correct
      ].join(","));
    }

    const csvSummary = sumLines.join("\n");
    const urlSummary = URL.createObjectURL(new Blob([csvSummary],{type:'text/csv'}));
    const fnameSummary = `flow_rsvp_summary_${S.pid||'anon'}.csv`;

    screen.innerHTML = `
      <h1>Finished 🎉</h1>
      <p class="center">Thanks for participating.</p>
      <div class="center" style="margin-top:16px">
        <a class="btn" id="dl1" download="${fnameEvents}">Download events CSV</a>
        <a class="btn" id="dl2" style="margin-left:8px" download="${fnameSummary}">Download summary CSV</a>
      </div>`;
    document.getElementById('dl1').href = urlEvents;
    document.getElementById('dl2').href = urlSummary;
  }

  // go
  pidPrompt();
})();
</script>
</body>
</html>
