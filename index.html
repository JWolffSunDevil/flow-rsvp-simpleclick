<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow Tapper + Peripheral RSVP (Yes/No + Likerts + Time 2AFC)</title>
<style>
  :root {
    --bg:#ffffff; --fg:#0f1720; --muted:#4b5563; --accent:#0b5fff;
    --border:#e5e7eb; --pill:#111827; --pill-border:#cbd5e1;
  }
  html,body { margin:0; padding:0; height:100%; background:var(--bg); color:var(--fg);
    font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;}
  #app { display:flex; align-items:center; justify-content:center; height:100%; }
  .card { width:min(900px,92vw); border:1px solid var(--border); border-radius:16px; padding:28px;
    box-shadow:0 10px 30px rgba(0,0,0,.07); background:linear-gradient(180deg,#ffffff 0%,#f9fafb 100%); }
  h1 { margin:0 0 6px 0; font-size:22px; color:#0b1220; }
  p { color:var(--muted); line-height:1.5; }
  .center { text-align:center; }
  .mid { font-size:36px; }
  .hint { font-size:14px; color:#6b7280; }
  .pill { padding:8px 12px; border-radius:999px; border:1px solid var(--pill-border); color:#111827; background:#f8fafc; }
  .layout {
    position:relative; height:60vh; min-height:420px; display:flex; align-items:center; justify-content:center;
    border:1px dashed var(--pill-border); border-radius:16px; margin:20px 0; background:#fff;
  }
  /* RSVP number centered above the dot */
  .rsvp { position:absolute; bottom:calc(50% + 140px); left:50%; transform:translateX(-50%);
    font-size:72px; color:#1f2937; opacity:.22; user-select:none; }
  .dot { width:84px; height:84px; border-radius:50%; background:var(--accent); opacity:.25;
    transition:transform .08s, opacity .08s; transform:scale(1); }
  .dot.flash { opacity:.95; transform:scale(1.08); }
  .btn { display:inline-block; background:#111827; border:1px solid #0f1720; color:#ffffff;
    padding:10px 14px; border-radius:10px; cursor:pointer; }
  .btn:hover{ filter:brightness(1.1);}
  .row { display:flex; gap:12px; justify-content:center; align-items:center; flex-wrap:wrap; margin-top:12px;}
  .two { display:grid; grid-template-columns:1fr 1fr; gap:16px; }
  .choice { padding:14px; border:1px solid var(--pill-border); border-radius:12px; text-align:center; font-size:28px; cursor:pointer; user-select:none; background:#fff; }
  .choice:hover { outline:2px solid #d1d5db; }
  input[type="text"]{ width:260px; padding:10px 12px; border-radius:10px; border:1px solid var(--pill-border); background:#fff; color:#0f1720; }
</style>
</head>
<body>
<div id="app"><div class="card"><div id="screen"></div></div></div>
<script>
(function(){
  // ===== CONFIG =====
  // All rounds use very fast RSVP (~60 Hz). Added masking to feel even faster.
  const ROUNDS = [
    {name:"Easy",   bpm:60,  rsvpHz:60, targetPool:[3,8,12,17,20]},
    {name:"Medium", bpm:90,  rsvpHz:60, targetPool:[2,5,11,14,19]},
    {name:"Hard",   bpm:120, rsvpHz:60, targetPool:[1,6,9,15,18]},
  ];
  const ROUND_DURATION_RANGE_MS = [15000, 60000]; // 15..60s
  const TARGETS_PER_ROUND = 6;
  const TARGET_FIRST_MS   = [3000,5000];
  const TARGET_GAP_MS     = [7000,11000];

  // Keys
  const YES_KEY   = "KeyF";           // recognition: Yes
  const NO_KEY    = "KeyJ";           // recognition: No
  const LIKERT5   = ["Digit1","Digit2","Digit3","Digit4","Digit5"]; // 1..5
  const LEFT_KEY  = "KeyF";           // time 2AFC: Left
  const RIGHT_KEY = "KeyJ";           // time 2AFC: Right

  // Likert labels
  const LABELS_CONF_5 = ["1 Â· Not at all","2 Â· Slightly","3 Â· Moderately","4 Â· Mostly","5 Â· Very"];
  // Concentration is intentionally reversed (1 = most, 5 = least)
  const LABELS_CONC_5 = ["1 Â· Extremely","2 Â· Very","3 Â· Moderately","4 Â· Slightly","5 Â· Not at all"];
  const LABELS_LOST_5 = ["1 Â· Not at all","2 Â· Slightly","3 Â· Somewhat","4 Â· Mostly","5 Â· Completely"];

  // Perceptual speed-up settings for RSVP
  const MASK_BLANK_PROB = 0.35; // chance to briefly blank the digit next frame to feel faster

  // ===== STATE =====
  const S = {
    pid: "",
    phase: "pid", roundIndex: -1,
    rafId: 0, keyHandler: null, keyTimeout: null,
    roundStart: 0, endAt: 0, nextBeatAt: 0, beatInterval: 600,
    nextRSVPAt: 0, rsvpInterval: 40,
    lastDigit: "", // for masking
    targets: [],                    // [{at, digit, shown}]
    rsvpShown: new Array(21).fill(0), // digits 1..20 seen (index 0 unused)
    transitioning: false,
    roundMeta: {}, // roundIndex -> {nTargetsShown}
    log: [],
  };

  // ===== UTILS =====
  const now = ()=>performance.now();
  const randint = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;
  const choice  = arr => arr[Math.floor(Math.random()*arr.length)];
  function sample(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  const screen = document.getElementById('screen');
  const html   = (s,...v)=> s.map((x,i)=> x + (v[i]??'')).join('');

  window.addEventListener('keydown', e=>{ if (typeof S.keyHandler==='function') S.keyHandler(e); });
  function setKeyHandler(allowed, ms, cb){
    clearKeyHandler();
    S.keyHandler = e=>{
      if (!allowed || allowed.includes(e.code)) { clearKeyHandler(); cb(e.code); }
    };
    if (ms>0) S.keyTimeout = setTimeout(()=>{ clearKeyHandler(); cb(null); }, ms);
  }
  function clearKeyHandler(){ if (S.keyTimeout){ clearTimeout(S.keyTimeout); S.keyTimeout=null; } S.keyHandler=null; }
  function cancelLoop(){ if (S.rafId){ cancelAnimationFrame(S.rafId); S.rafId=0; } }

  // ===== TARGET SCHEDULER =====
  function scheduleTargets(duration, targetPool){
    const out=[]; let t = randint(...TARGET_FIRST_MS);
    for (let i=0;i<TARGETS_PER_ROUND;i++){
      out.push({at:t, digit: sample(targetPool), shown:false});
      t += randint(...TARGET_GAP_MS);
      if (t>duration-1000) break;
    }
    return out;
  }

  // ===== PID PROMPT =====
  function pidPrompt(){
    cancelLoop(); clearKeyHandler(); S.phase='pid';
    screen.innerHTML = html`
      <h1>Enter Participant ID</h1>
      <p class="hint">Type your ID, then press Enter.</p>
      <div class="center" style="margin-top:10px">
        <input id="pid" type="text" placeholder="e.g., P001" autofocus />
      </div>
    `;
    const el = document.getElementById('pid');
    el.focus();
    S.keyHandler = (e)=>{
      if (e.code==='Enter'){
        const v = el.value.trim();
        if (v.length>0){ S.pid = v; intro(); }
      }
    };
  }

  // ===== INTRO =====
  function intro(){
    cancelLoop(); clearKeyHandler(); S.phase='intro';
    screen.innerHTML = html`
      <h1>Tap the dot in rhythm</h1>
      <p>Press <strong>SPACE</strong> whenever the dot flashes. Keep your eyes on the dot and play naturally; numbers will also flash above the dot. We'll test whether you can recall numbers shown after the game. This test will measure intelligence.
      <br><br><em>This game has three rounds, and should take less than 10 minutes to complete. Thank you for your full participation.</em></p>
      <div class="layout"><div class="rsvp">17</div><div class="dot" id="dot"></div></div>
      <div class="center"><button class="btn" id="start">Start</button></div>`;
    document.getElementById('start').onclick = ()=> startNextRound();
  }

  function startNextRound(){
    if (S.transitioning) return;
    S.transitioning = true;
    S.roundIndex++;
    if (S.roundIndex>=ROUNDS.length) { finish(); return; }
    setTimeout(()=>{ S.transitioning=false; runRound(ROUNDS[S.roundIndex]); }, 0);
  }

  // ===== RUN ROUND =====
  function runRound(cfg){
    cancelLoop(); clearKeyHandler(); S.phase='round';
    S.roundStart = now();
    const runDuration = randint(...ROUND_DURATION_RANGE_MS);
    S.endAt      = S.roundStart + runDuration;

    S.beatInterval = 60000/cfg.bpm;
    S.nextBeatAt   = S.roundStart + S.beatInterval;
    S.rsvpInterval = Math.max(16, Math.round(1000/cfg.rsvpHz)); // ~60 fps cap
    S.nextRSVPAt   = S.roundStart + S.rsvpInterval;

    S.targets     = scheduleTargets(runDuration, cfg.targetPool);
    S.rsvpShown   = new Array(21).fill(0); // 1..20
    S.lastDigit   = "";

    S.log.push({pid:S.pid, type:'ROUND_START', round:S.roundIndex, roundName:cfg.name, ts:0,
                bpm:cfg.bpm, rsvpHz:cfg.rsvpHz, plannedMs:runDuration});

    screen.innerHTML = html`
      <div class="row" style="justify-content:space-between">
        <div class="pill">${cfg.name}</div>
        <div class="hint">Press SPACE</div>
      </div>
      <div class="layout"><div id="rsvp" class="rsvp"></div><div id="dot" class="dot"></div></div>`;
    const dot   = document.getElementById('dot');
    const elRSV = document.getElementById('rsvp');

    setKeyHandler(["Space"], 0, ()=>{
      const t = now();
      S.log.push({pid:S.pid, type:'TAP', round:S.roundIndex, roundName:cfg.name, ts:Math.round(t-S.roundStart)});
    });

    function loop(){
      const t = now();
      if (t>=S.endAt){ cancelLoop(); clearKeyHandler(); return postRound(cfg, runDuration); }

      // Jittered beats (Â±35%)
      while (t>=S.nextBeatAt){
        const jitter = 0.35;
        const base = S.beatInterval;
        const factor = 1 + (Math.random()*2-1)*jitter;
        S.nextBeatAt = t + base * factor;
        dot.classList.add('flash');
        setTimeout(()=>dot.classList.remove('flash'),120);
        S.log.push({pid:S.pid, type:'BEAT', round:S.roundIndex, roundName:cfg.name, ts:Math.round(t-S.roundStart)});
      }

      // RSVP digits (every frame at ~60Hz, with occasional blank mask to feel faster)
      while (t>=S.nextRSVPAt){
        S.nextRSVPAt += S.rsvpInterval;

        let digit = randint(1,20);
        const elapsed = t - S.roundStart;

        // force scheduled targets near their time
        for (const tgt of S.targets){
          if (!tgt.shown && Math.abs(elapsed - tgt.at) <= S.rsvpInterval){
            digit = tgt.digit; tgt.shown=true; break;
          }
        }

        S.rsvpShown[digit] = 1;
        S.lastDigit = String(digit);
        elRSV.textContent = S.lastDigit;
        S.log.push({pid:S.pid, type:'RSVP', round:S.roundIndex, roundName:cfg.name,
                    ts:Math.round(elapsed), digit});
      }

      // Perceptual â€œspeed-upâ€: randomly insert blank frames
      if (S.lastDigit && Math.random() < MASK_BLANK_PROB){
        elRSV.textContent = ""; // brief mask to reduce persistence
      }

      S.rafId = requestAnimationFrame(loop);
    }
    S.rafId = requestAnimationFrame(loop);
  }

  // ===== AFTER ROUND =====
  function postRound(cfg, runDuration){
    const nTargetsShown = new Set(S.targets.filter(t=>t.shown).map(t=>t.digit)).size;
    S.roundMeta[S.roundIndex] = { nTargetsShown };
    S.log.push({pid:S.pid, type:'ROUND_META', round:S.roundIndex, roundName:cfg.name, nTargetsShown});

    S.log.push({pid:S.pid, type:'ROUND_END', round:S.roundIndex, roundName:cfg.name,
                ts:Math.round(now()-S.roundStart)});

    // Build one probe (prefer actual target, else true foil)
    const uniqTargets = Array.from(new Set(S.targets.filter(t=>t.shown).map(t=>t.digit)));
    const unseen = []; for (let d=1; d<=20; d++){ if (!S.rsvpShown[d]) unseen.push(d); }
    if (unseen.length===0){ for (let d=1; d<=20; d++){ if (!uniqTargets.includes(d)) unseen.push(d); } }

    const probe = (uniqTargets.length>0)
      ? {digit: choice(uniqTargets), isTarget:true}
      : {digit: choice(unseen.length?unseen:[randint(1,20)]), isTarget:false};

    yesNoProbe(probe, ()=> afterRoundSequence(cfg, runDuration), cfg);
  }

  function yesNoProbe(probe, done){
    cancelLoop(); clearKeyHandler();
    screen.innerHTML = html`
      <h1>Did you see this number?</h1>
      <div class="center mid" style="margin:16px 0">${probe.digit}</div>
      <p class="center hint">Press <strong>F</strong> = Yes, <strong>J</strong> = No</p>
    `;
    const start = now();
    setKeyHandler([YES_KEY, NO_KEY], 20000, (code)=>{
      const rt = Math.round(now()-start);
      const respYes = code===YES_KEY ? 1 : code===NO_KEY ? 0 : null;
      const correct = respYes===null ? 0 : (respYes===1 ? (probe.isTarget?1:0) : (probe.isTarget?0:1));
      S.log.push({
        pid:S.pid, type:'PROBE', round:S.roundIndex, roundName:ROUNDS[S.roundIndex].name,
        ts:Math.round(now()-S.roundStart),
        probe_digit: probe.digit, is_target: probe.isTarget?1:0,
        resp_yes: respYes, correct
      });
      done();
    });
  }

  // ===== Likert UI (Confidence, Concentration [reversed], Lost-time) =====
  function askLikert(title, labels, keyset, logType, valueField, next){
    cancelLoop(); clearKeyHandler();
    screen.innerHTML = html`
      <h1>${title}</h1>
      <div class="row">
        ${labels.map(l=>`<span class="pill">${l}</span>`).join("")}
      </div>
      <p class="center hint">Press 1..${labels.length}</p>`;
    const t0 = now();
    setKeyHandler(keyset, 20000, code=>{
      const v = code ? (keyset.indexOf(code)+1) : null;
      const rt = Math.round(now()-t0);
      const rec = {pid:S.pid, type:logType, round:S.roundIndex, roundName:ROUNDS[S.roundIndex].name, ts:Math.round(now()-S.roundStart), rt};
      if (valueField) rec[valueField] = v; else rec.val = v;
      S.log.push(rec);
      next();
    });
  }

  // Order: Confidence â†’ Concentration (reversed labels) â†’ Lost-time â†’ Time 2AFC
  function afterRoundSequence(cfg, runDuration){
    askLikert("Confidence (1..5)", LABELS_CONF_5, LIKERT5, "CONF", "confidence", ()=> {
      askLikert("How concentrated were you? (1..5)", LABELS_CONC_5, LIKERT5, "FLOW_CONC", "concentration", ()=> {
        askLikert("I lost track of time (1..5)", LABELS_LOST_5, LIKERT5, "FLOW_LOST", "lost_time", ()=> {
          timeTwoAFC(cfg, runDuration);
        });
      });
    });
  }

  // ===== TIME 2AFC (foil differs by â‰¥ 15s) =====
  function timeTwoAFC(cfg, runDuration){
    cancelLoop(); clearKeyHandler();
    const actualSec = Math.round(runDuration/1000);

    // pick a delta with |delta| >= 15
    const DELTAS = [15,16,18,20,22,25,30,35,40,45];
    let delta = sample(DELTAS);
    if (Math.random()<0.5) delta = -delta;

    let foilSec = actualSec + delta;
    // clamp and ensure distinct and â‰¥15 away
    foilSec = Math.max(15, Math.min(60, foilSec));
    if (Math.abs(foilSec - actualSec) < 15){
      // push away from actual keeping bounds
      foilSec = (actualSec <= 30) ? Math.min(60, actualSec + 15) : Math.max(15, actualSec - 15);
    }
    if (foilSec === actualSec){
      foilSec = (actualSec + 15 <= 60) ? actualSec + 15 : actualSec - 15;
    }

    const leftIsCorrect = Math.random()<0.5;
    const L = leftIsCorrect ? actualSec : foilSec;
    const R = leftIsCorrect ? foilSec : actualSec;

    screen.innerHTML = html`
      <h1>How long did that round last?</h1>
      <div class="two">
        <div class="choice" id="left">${L} sec</div>
        <div class="choice" id="right">${R} sec</div>
      </div>
      <p class="center hint">Press <strong>F</strong> (left) or <strong>J</strong> (right)</p>
    `;
    const start = now();
    setKeyHandler([LEFT_KEY, RIGHT_KEY], 20000, (code)=>{
      const rt = Math.round(now()-start);
      const pickLeft = code===LEFT_KEY ? 1 : code===RIGHT_KEY ? 0 : null;
      const chosen = pickLeft===null ? null : (pickLeft ? L : R);
      const correct = chosen===null ? 0 : (chosen===actualSec ? 1 : 0);
      S.log.push({
        pid:S.pid, type:'TIME_2AFC', round:S.roundIndex, roundName:cfg.name,
        left:L, right:R, leftIsCorrect:leftIsCorrect?1:0, choice_left:pickLeft, chosen, correct, rt
      });
      startNextRound();
    });
  }

  // ===== FINISH & CSVs =====
  function finish(){
    cancelLoop(); clearKeyHandler();

    // 1) Events CSV (full detail for analysis)
    const cols = ["pid","round","roundName","type","ts","digit","probe_digit","is_target","resp_yes","correct","confidence","concentration","lost_time","seconds","bpm","rsvpHz","plannedMs","left","right","leftIsCorrect","choice_left","chosen"];
    const lines = [cols.join(",")];
    for (const r of S.log){
      const row = {
        pid: r.pid ?? S.pid,
        round: r.round ?? "",
        roundName: r.roundName ?? "",
        type: r.type ?? "",
        ts: r.ts ?? "",
        digit: r.digit ?? "",
        probe_digit: r.probe_digit ?? "",
        is_target: r.is_target ?? "",
        resp_yes: r.resp_yes ?? "",
        correct: r.correct ?? "",
        confidence: r.confidence ?? "",
        concentration: r.concentration ?? "",
        lost_time: r.lost_time ?? "",
        seconds: r.seconds ?? "",
        bpm: r.bpm ?? "",
        rsvpHz: r.rsvpHz ?? "",
        plannedMs: r.plannedMs ?? "",
        left: r.left ?? "",
        right: r.right ?? "",
        leftIsCorrect: r.leftIsCorrect ?? "",
        choice_left: r.choice_left ?? "",
        chosen: r.chosen ?? ""
      };
      lines.push(cols.map(k=>row[k]).join(","));
    }
    const csvEvents = lines.join("\n");
    const urlEvents = URL.createObjectURL(new Blob([csvEvents],{type:'text/csv'}));
    const fnameEvents = `flow_rsvp_events_${S.pid||'anon'}.csv`;

    // 2) Round Summary CSV (clean)
    const sumCols = [
      "participant_id","round_index","round_name",
      "planned_duration_seconds","actual_duration_seconds",
      "beats_per_minute","rsvp_rate_hz",
      "taps_count","beats_count","targets_shown_count",
      "recognition_digit","recognition_was_scheduled_target","recognition_answer_yes","recognition_correct",
      "confidence_1to5","concentration_1to5","lost_time_1to5",
      "time_options_left_seconds","time_options_right_seconds","time_chosen_left","time_chosen_seconds","time_choice_correct"
    ];
    const sumLines = [sumCols.join(",")];

    const allRounds = Array.from(new Set(S.log.map(x=>x.round))).filter(r=>r!==undefined && r!==null);
    for (const rIdx of allRounds){
      const rows = S.log.filter(x=>x.round===rIdx);
      const roundName = rows.find(x=>x.roundName)?.roundName || "";
      const plannedMs = (rows.find(x=>x.type==="ROUND_START")?.plannedMs) || "";
      const actualMs  = (rows.find(x=>x.type==="ROUND_END")?.ts) || "";
      const bpm       = rows.find(x=>x.type==="ROUND_START")?.bpm ?? "";
      const rsvpHz    = rows.find(x=>x.type==="ROUND_START")?.rsvpHz ?? "";
      const tapsCount  = rows.filter(x=>x.type==="TAP").length;
      const beatsCount = rows.filter(x=>x.type==="BEAT").length;
      const targetsShownCount = rows.find(x=>x.type==="ROUND_META")?.nTargetsShown ?? "";

      const probe = rows.find(x=>x.type==="PROBE");
      const conf  = rows.find(x=>x.type==="CONF")?.confidence ?? "";
      const conc  = rows.find(x=>x.type==="FLOW_CONC")?.concentration ?? "";
      const lost  = rows.find(x=>x.type==="FLOW_LOST")?.lost_time ?? "";

      const time2 = rows.find(x=>x.type==="TIME_2AFC");
      const left  = time2?.left ?? "";
      const right = time2?.right ?? "";
      const choice_left = time2?.choice_left ?? "";
      const chosen = time2?.chosen ?? "";
      const time_correct = time2?.correct ?? "";

      sumLines.push([
        S.pid, rIdx, roundName,
        plannedMs?Math.round(plannedMs/1000):"",
        actualMs?Math.round(actualMs/1000):"",
        bpm, rsvpHz,
        tapsCount, beatsCount, targetsShownCount,
        probe?.probe_digit ?? "",
        probe?.is_target ?? "",
        probe?.resp_yes ?? "",
        probe?.correct ?? "",
        conf, conc, lost,
        left, right, choice_left, chosen, time_correct
      ].join(","));
    }

    const csvSummary = sumLines.join("\n");
    const urlSummary = URL.createObjectURL(new Blob([csvSummary],{type:'text/csv'}));
    const fnameSummary = `flow_rsvp_summary_${S.pid||'anon'}.csv`;

    screen.innerHTML = `
      <h1>Finished ðŸŽ‰</h1>
      <p class="center">Thanks for participating.</p>
      <div class="center" style="margin-top:16px">
        <a class="btn" id="dl1" download="${fnameEvents}">Download events CSV</a>
        <a class="btn" id="dl2" style="margin-left:8px" download="${fnameSummary}">Download summary CSV</a>
      </div>`;
    document.getElementById('dl1').href = urlEvents;
    document.getElementById('dl2').href = urlSummary;
  }

  // go
  pidPrompt();
})();
</script>
</body>
</html>
